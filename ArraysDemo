package basics;
/*
Для заданного массива вычислить среднее квадратическое отклонение.
Для заданного массива найти самую длинную последовательность повторяющихся элементов.
Посчитать количество элементов массива, у которых четность совпадает с четностью их индексов.
Удалить в массиве все числа, которые повторяются более двух раз.

Морской бой
Одним из этапов программирования данной игры является расстановка кораблей на игровом поле. Если вы решите ряд данных задач, будьте уверены, морской бой вам по зубам. 
Итак, дана матрица 10х10, состоящая из нулей.
Предположим, что она является полем для игры в морской бой. В данном поле 0 — пустая ячейка, 1 — корабль, либо часть корабля. 
Написать функции, каждая из которых по правилам игры морской бой расставляет случайным образом:
10 однопалубных кораблей;
10 двухпалубных корбалей;
5 трехпалубных кораблей;
расставляет все корабли для игры в морской бой (4 однопалубных, 3 двухпалубных, 2 трехпалубных, 1 четырехпалубный).

1. Найти количество элементов массива, встречающихся в массиве два раза. 
2. Вывести все неповторяющиеся элементы массива. 
3. Объединить два массива одинакового размера, в котором элементы отсортированы в убывающем порядке. Элементы результирующего массива также расположены в убывающем порядке. 
4. Определить количество повторений каждого элемента массива. 
6. Вывести элементы массива и количество их повторений. 
7. Отсортировать элементы массива в возрастающем порядке. 
8. Найти все пары элементов массива, сумма которых равна заданному числу. 
9. Вывести подмассив с наибольшей суммой его элементов. 
10. Определить пропущенные числа в массиве, элементы которого не повторяются. 
11. Найти минимальный отсутствующий элемент массива. 
12. Найти два элемента массива, сумма которых ближе всего к нулю.

Выяснить, является ли массив возрастающей последовательностью простых чисел.
Дана последовательность. Найти среднее арифметическое для его неповторяющегося подмножества.
Даны две неупорядоченные последовательности. Выяснить, является ли одна из них подможеством другой.
Найти в заданной последовательности положительную подпоследовательность наибольшей длины.
Определить, сколько чисел и какие входят в последовательность более чем по одному разу.
В последовательности найти два числа, среднее арифметическое которых ближе всего к заданному числу.
Выяснить, является ли последовательность симметричной последовательностью простых чисел.

*/
import java.util.Arrays;

public class ArraysTasks {
     public static void main(String[] args) {
         /*
         Для заданного массива вещественных чисел вычислить среднее квадратическое отклонение.
         Даны два массива вещественных чисел. Найти коэффициент корреляции Пирсона.
         Дан целочисленный массив, в котором числа расположены в порядке возрастания. Возможно, что одно или несколько чисел пропущено. Определить позицию первого пропущенного числа, а если такого нет, вывести -1.
         Дан  массив целыъ чисел, больших 1 и число n. Найти n-е простое число. Если такого нет, вывести 0.
         Поместить в массив все простые трехзначные числа, являющиеся палиндромами.         
         */
         
         System.out.println(variance(new double[]{8,10,11}));
         System.out.println(korr(new double[]{1,2,3}, new double[]{2,4,5}));         
         System.out.println(lostNumber(new int[]{2,3,4,5,7,8}));
         //System.out.println(isPrime(12));
         System.out.println(nthPrime(new int[]{2,3,2,6,7,8,11}, 4));
         System.out.println(Arrays.toString(palindroms3()));
         
     }
     
     static double variance(double[] arr){
         double mean = 0;
         double sum = 0;
         for (double elem:arr)
             sum+=elem;
         mean = sum/arr.length;
         double deviation = 0;
         for (double elem:arr)
             deviation+=(elem-mean)*(elem-mean);
         //System.out.println(deviation);
         return Math.sqrt(1./(arr.length-1)*deviation);
     }
     
     static double korr(double[] x, double[] y){
         double meanX = 0;
         for (double elem:x)
             meanX+=elem;
         meanX/=x.length;
         
         double meanY = 0;
         for (double elem:y)
             meanY+=elem;
         meanY/=y.length;
         
         double nom = 0; //Числитель
         for (int i=0; i<x.length; i++)
             nom+=(x[i]-meanX)*(y[i]-meanY);
         
         double a = 0;
         for (double elem:x)
             a+=(elem-meanX)*(elem-meanX);
         
         double b = 0;
         for (double elem:y)
             b+=(elem-meanY)*(elem-meanY);
         return nom/Math.sqrt(a*b);
     }
     
     static int lostNumber(int[] arr){
         int first = arr[0];
         int index = -1;
         for (int i=1; i<arr.length; i++)
             if (arr[i]-first-i>0) {
                 index=i;
                 break;
             }
         return index;
     }
     
     static boolean isPrime(int n){
         for (int i=2; i<=Math.sqrt(n); i++)
             if (n%i==0) return false;
         return true;
     }
     
     static int nthPrime(int[] arr, int n){
         int result = 0;
         int index = 0;
         for (int elem:arr){
             if (isPrime(elem)) {                                  
                 index++;
                 if (index==n)
                     result = elem;
             }                  
         }
         return result;
     }
     
     static int[] palindroms3(){
         int count = 0;
         for (int i=100; i<1000; i++)
             if (isPrime(i) && i/100==i%10)
                count++;
         
         int[] arr = new int[count];
         int index = 0;
         for (int i=100; i<1000; i++)
             if (isPrime(i) && i/100==i%10)
                arr[index++] = i;
         
         return arr;    
     }
}
